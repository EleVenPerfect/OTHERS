; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_spi_ad7606.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_spi_ad7606.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX --omf_browse=.\flash\obj\bsp_spi_ad7606.crf ..\..\User\bsp_stm32f4xx\src\bsp_spi_ad7606.c]
                          THUMB

                          AREA ||i.AD7606_CfgSpiHard||, CODE, READONLY, ALIGN=2

                  AD7606_CfgSpiHard PROC
;;;192    */
;;;193    void AD7606_CfgSpiHard(void)
000000  b500              PUSH     {lr}
;;;194    {
000002  b085              SUB      sp,sp,#0x14
;;;195    	SPI_InitTypeDef  SPI_InitStructure;
;;;196    
;;;197    	/* 配置SPI硬件参数 */
;;;198    	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;	/* 数据方向：2线全双工 */
000004  2000              MOVS     r0,#0
000006  f8ad0000          STRH     r0,[sp,#0]
;;;199    	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		/* STM32的SPI工作模式 ：主机模式 */
00000a  f44f7082          MOV      r0,#0x104
00000e  f8ad0002          STRH     r0,[sp,#2]
;;;200    	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;	/* 数据位长度 ： 8位 */
000012  2000              MOVS     r0,#0
000014  f8ad0004          STRH     r0,[sp,#4]
;;;201    	/* SPI_CPOL和SPI_CPHA结合使用决定时钟和数据采样点的相位关系、
;;;202    	   本例配置: 总线空闲是高电平,第2个边沿（上升沿采样数据)
;;;203    	*/
;;;204    	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;			/* 时钟上升沿采样数据 */
000018  2002              MOVS     r0,#2
00001a  f8ad0006          STRH     r0,[sp,#6]
;;;205    	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;		/* 时钟的第2个边沿采样数据 */
00001e  2001              MOVS     r0,#1
000020  f8ad0008          STRH     r0,[sp,#8]
;;;206    	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;			/* 片选控制方式：软件控制 */
000024  0240              LSLS     r0,r0,#9
000026  f8ad000a          STRH     r0,[sp,#0xa]
;;;207    
;;;208    	/* 设置波特率预分频系数 SPI_BaudRatePrescaler_64 实测SCK周期 800ns ，12.5MHz */
;;;209    	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_64;
00002a  2028              MOVS     r0,#0x28
00002c  f8ad000c          STRH     r0,[sp,#0xc]
;;;210    
;;;211    	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	/* 数据位传输次序：高位先传 */
000030  2000              MOVS     r0,#0
000032  f8ad000e          STRH     r0,[sp,#0xe]
;;;212    	SPI_InitStructure.SPI_CRCPolynomial = 7;			/* CRC多项式寄存器，复位后为7。本例程不用 */
000036  2007              MOVS     r0,#7
000038  f8ad0010          STRH     r0,[sp,#0x10]
;;;213    	SPI_Init(SPI1, &SPI_InitStructure);
00003c  4669              MOV      r1,sp
00003e  4804              LDR      r0,|L1.80|
000040  f7fffffe          BL       SPI_Init
;;;214    
;;;215    	SPI_Cmd(SPI1, ENABLE);				/* 使能SPI  */
000044  2101              MOVS     r1,#1
000046  4802              LDR      r0,|L1.80|
000048  f7fffffe          BL       SPI_Cmd
;;;216    }
00004c  b005              ADD      sp,sp,#0x14
00004e  bd00              POP      {pc}
;;;217    
                          ENDP

                  |L1.80|
                          DCD      0x40013000

                          AREA ||i.AD7606_ConfigGPIO||, CODE, READONLY, ALIGN=2

                  AD7606_ConfigGPIO PROC
;;;137    */
;;;138    static void AD7606_ConfigGPIO(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;139    {
;;;140    	GPIO_InitTypeDef GPIO_InitStructure;
;;;141    
;;;142    	/* 打开GPIO时钟 */
;;;143    	RCC_AHB1PeriphClockCmd(RCC_CS | RCC_RANGE | RCC_BUSY | RCC_RESET | RCC_CONVST | RCC_OS0 | RCC_OS1 | RCC_OS2 , ENABLE);
000002  2101              MOVS     r1,#1
000004  205a              MOVS     r0,#0x5a
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;144    
;;;145    	/* 配置几个推完输出IO */
;;;146    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;		/* 设为输出口 */
00000a  2001              MOVS     r0,#1
00000c  f88d0004          STRB     r0,[sp,#4]
;;;147    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
000010  2000              MOVS     r0,#0
000012  f88d0006          STRB     r0,[sp,#6]
;;;148    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 上下拉电阻不使能 */
000016  f88d0007          STRB     r0,[sp,#7]
;;;149    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;	/* IO口最大速度 */
00001a  2003              MOVS     r0,#3
00001c  f88d0005          STRB     r0,[sp,#5]
;;;150    
;;;151    	GPIO_InitStructure.GPIO_Pin = PIN_RESET;
000020  f44f7000          MOV      r0,#0x200
000024  9000              STR      r0,[sp,#0]
;;;152    	GPIO_Init(PORT_RESET, &GPIO_InitStructure);
000026  4669              MOV      r1,sp
000028  481f              LDR      r0,|L2.168|
00002a  f7fffffe          BL       GPIO_Init
;;;153    
;;;154    	GPIO_InitStructure.GPIO_Pin = PIN_CONVST;
00002e  f44f6080          MOV      r0,#0x400
000032  9000              STR      r0,[sp,#0]
;;;155    	GPIO_Init(PORT_CONVST, &GPIO_InitStructure);
000034  4669              MOV      r1,sp
000036  481c              LDR      r0,|L2.168|
000038  f7fffffe          BL       GPIO_Init
;;;156    	
;;;157    	GPIO_InitStructure.GPIO_Pin = PIN_RANGE;
00003c  2001              MOVS     r0,#1
00003e  9000              STR      r0,[sp,#0]
;;;158    	GPIO_Init(PORT_RANGE, &GPIO_InitStructure);
000040  4669              MOV      r1,sp
000042  481a              LDR      r0,|L2.172|
000044  f7fffffe          BL       GPIO_Init
;;;159    	
;;;160    	GPIO_InitStructure.GPIO_Pin = PIN_CS;
000048  f44f4000          MOV      r0,#0x8000
00004c  9000              STR      r0,[sp,#0]
;;;161    	GPIO_Init(PORT_CS, &GPIO_InitStructure);
00004e  4669              MOV      r1,sp
000050  4817              LDR      r0,|L2.176|
000052  f7fffffe          BL       GPIO_Init
;;;162    	
;;;163    	GPIO_InitStructure.GPIO_Pin = PIN_OS0;
000056  f44f5000          MOV      r0,#0x2000
00005a  9000              STR      r0,[sp,#0]
;;;164    	GPIO_Init(PORT_OS0, &GPIO_InitStructure);
00005c  4669              MOV      r1,sp
00005e  4814              LDR      r0,|L2.176|
000060  f7fffffe          BL       GPIO_Init
;;;165    	
;;;166    	GPIO_InitStructure.GPIO_Pin = PIN_OS1;
000064  2004              MOVS     r0,#4
000066  9000              STR      r0,[sp,#0]
;;;167    	GPIO_Init(PORT_OS1, &GPIO_InitStructure);
000068  4669              MOV      r1,sp
00006a  4811              LDR      r0,|L2.176|
00006c  f7fffffe          BL       GPIO_Init
;;;168    	
;;;169    	GPIO_InitStructure.GPIO_Pin = PIN_OS2;
000070  f44f4000          MOV      r0,#0x8000
000074  9000              STR      r0,[sp,#0]
;;;170    	GPIO_Init(PORT_OS2, &GPIO_InitStructure);
000076  4669              MOV      r1,sp
000078  480e              LDR      r0,|L2.180|
00007a  f7fffffe          BL       GPIO_Init
;;;171    
;;;172    
;;;173    	ADC_OS0_ON	;			//临时用于VIO输出引脚
00007e  f44f5000          MOV      r0,#0x2000
000082  490b              LDR      r1,|L2.176|
000084  8348              STRH     r0,[r1,#0x1a]
;;;174    	
;;;175    	/* 配置GPIO为浮动输入模式(实际上CPU复位后就是输入状态) */
;;;176    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;		/* 设为输入口 */
000086  2000              MOVS     r0,#0
000088  f88d0004          STRB     r0,[sp,#4]
;;;177    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
00008c  f88d0006          STRB     r0,[sp,#6]
;;;178    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 无需上下拉电阻 */
000090  f88d0007          STRB     r0,[sp,#7]
;;;179    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	/* IO口最大速度 */
000094  2002              MOVS     r0,#2
000096  f88d0005          STRB     r0,[sp,#5]
;;;180    
;;;181    	GPIO_InitStructure.GPIO_Pin = PIN_BUSY;
00009a  0340              LSLS     r0,r0,#13
00009c  9000              STR      r0,[sp,#0]
;;;182    	GPIO_Init(PORT_BUSY, &GPIO_InitStructure);
00009e  4669              MOV      r1,sp
0000a0  4803              LDR      r0,|L2.176|
0000a2  f7fffffe          BL       GPIO_Init
;;;183    }
0000a6  bd1c              POP      {r2-r4,pc}
;;;184    
                          ENDP

                  |L2.168|
                          DCD      0x40020c00
                  |L2.172|
                          DCD      0x40020400
                  |L2.176|
                          DCD      0x40021000
                  |L2.180|
                          DCD      0x40021800

                          AREA ||i.AD7606_ReadAdc||, CODE, READONLY, ALIGN=2

                  AD7606_ReadAdc PROC
;;;376    */
;;;377    int16_t AD7606_ReadAdc(uint8_t _ch)
000000  4601              MOV      r1,r0
;;;378    {
;;;379    	int16_t sAdc;
;;;380    	
;;;381    	DISABLE_INT();	
000002  2001              MOVS     r0,#1
000004  f3808810          MSR      PRIMASK,r0
000008  bf00              NOP      
;;;382    	sAdc = s_adc_now[_ch];
00000a  4804              LDR      r0,|L3.28|
00000c  f9302011          LDRSH    r2,[r0,r1,LSL #1]
;;;383    	ENABLE_INT();
000010  2000              MOVS     r0,#0
000012  f3808810          MSR      PRIMASK,r0
000016  bf00              NOP      
;;;384    
;;;385    	return sAdc;
000018  4610              MOV      r0,r2
;;;386    }
00001a  4770              BX       lr
;;;387    
                          ENDP

                  |L3.28|
                          DCD      s_adc_now

                          AREA ||i.AD7606_Reset||, CODE, READONLY, ALIGN=2

                  AD7606_Reset PROC
;;;302    */
;;;303    void AD7606_Reset(void)
000000  b510              PUSH     {r4,lr}
;;;304    {
;;;305    	/* CS  SCLK拉高 */
;;;306    #ifdef SOFT_SPI
;;;307    		AD_CS_1();
000002  f44f4100          MOV      r1,#0x8000
000006  4811              LDR      r0,|L4.76|
000008  f7fffffe          BL       GPIO_SetBits
;;;308    		//SCK_1();
;;;309    #endif
;;;310    
;;;311     	/* AD7606是高电平复位，要求最小脉宽50ns */
;;;312    	AD_RESET_LOW();
00000c  f44f7100          MOV      r1,#0x200
000010  480f              LDR      r0,|L4.80|
000012  f7fffffe          BL       GPIO_ResetBits
;;;313    	
;;;314    	AD_RESET_HIGH();
000016  f44f7100          MOV      r1,#0x200
00001a  480d              LDR      r0,|L4.80|
00001c  f7fffffe          BL       GPIO_SetBits
;;;315    	AD_RESET_HIGH();
000020  f44f7100          MOV      r1,#0x200
000024  480a              LDR      r0,|L4.80|
000026  f7fffffe          BL       GPIO_SetBits
;;;316    	AD_RESET_HIGH();
00002a  f44f7100          MOV      r1,#0x200
00002e  4808              LDR      r0,|L4.80|
000030  f7fffffe          BL       GPIO_SetBits
;;;317    	AD_RESET_HIGH();
000034  f44f7100          MOV      r1,#0x200
000038  4805              LDR      r0,|L4.80|
00003a  f7fffffe          BL       GPIO_SetBits
;;;318    	
;;;319    	AD_RESET_LOW();
00003e  f44f7100          MOV      r1,#0x200
000042  4803              LDR      r0,|L4.80|
000044  f7fffffe          BL       GPIO_ResetBits
;;;320    }
000048  bd10              POP      {r4,pc}
;;;321    /*
                          ENDP

00004a  0000              DCW      0x0000
                  |L4.76|
                          DCD      0x40021000
                  |L4.80|
                          DCD      0x40020c00

                          AREA ||i.AD7606_Scan||, CODE, READONLY, ALIGN=2

                  AD7606_Scan PROC
;;;346    */
;;;347    void AD7606_Scan(void) 		/* 此函数代码按照时序编写 */
000000  b510              PUSH     {r4,lr}
;;;348    {
;;;349    	uint8_t i;			
;;;350    
;;;351    	/* BUSY = 0 时.ad7606处于空闲状态ad转换结束 */	
;;;352    	if (BUSY_IS_LOW())	   
000002  f44f4180          MOV      r1,#0x4000
000006  4813              LDR      r0,|L5.84|
000008  f7fffffe          BL       GPIO_ReadInputDataBit
00000c  bb08              CBNZ     r0,|L5.82|
;;;353        {
;;;354    		AD_CS_0(); /* SPI片选 = 0 */
00000e  f44f4100          MOV      r1,#0x8000
000012  4810              LDR      r0,|L5.84|
000014  f7fffffe          BL       GPIO_ResetBits
;;;355    	
;;;356    		for (i = 0; i < CH_NUM; i++)
000018  2400              MOVS     r4,#0
00001a  e011              B        |L5.64|
                  |L5.28|
;;;357    		{
;;;358    			s_adc_now[i] = bsp_spiRead1();
00001c  f7fffffe          BL       bsp_spiRead1
000020  490d              LDR      r1,|L5.88|
000022  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;359    			
;;;360    			s_adc_now[i] = s_adc_now[i] * 256 + bsp_spiRead1(); /* 读数据 */	
000026  f7fffffe          BL       bsp_spiRead1
00002a  490b              LDR      r1,|L5.88|
00002c  f8111014          LDRB     r1,[r1,r4,LSL #1]
000030  eb002001          ADD      r0,r0,r1,LSL #8
000034  b200              SXTH     r0,r0
000036  4908              LDR      r1,|L5.88|
000038  f8210014          STRH     r0,[r1,r4,LSL #1]
00003c  1c60              ADDS     r0,r4,#1              ;356
00003e  b2c4              UXTB     r4,r0                 ;356
                  |L5.64|
000040  2c08              CMP      r4,#8                 ;356
000042  dbeb              BLT      |L5.28|
;;;361    		}
;;;362    	
;;;363    		AD_CS_1(); /* SPI片选 = 1 */
000044  f44f4100          MOV      r1,#0x8000
000048  4802              LDR      r0,|L5.84|
00004a  f7fffffe          BL       GPIO_SetBits
;;;364    
;;;365    		AD7606_StartConv();	/* 给开始信号 */	
00004e  f7fffffe          BL       AD7606_StartConv
                  |L5.82|
;;;366    	}
;;;367    }	  
000052  bd10              POP      {r4,pc}
;;;368    
                          ENDP

                  |L5.84|
                          DCD      0x40021000
                  |L5.88|
                          DCD      s_adc_now

                          AREA ||i.AD7606_SetInputRange||, CODE, READONLY, ALIGN=2

                  AD7606_SetInputRange PROC
;;;282    */
;;;283    void AD7606_SetInputRange(uint8_t _ucRange)
000000  b510              PUSH     {r4,lr}
;;;284    {
000002  4604              MOV      r4,r0
;;;285    	if (_ucRange == 0)
000004  b924              CBNZ     r4,|L6.16|
;;;286    	{
;;;287    		AD_RANGE_5V();	/* 设置为正负5V */
000006  2101              MOVS     r1,#1
000008  4804              LDR      r0,|L6.28|
00000a  f7fffffe          BL       GPIO_ResetBits
00000e  e003              B        |L6.24|
                  |L6.16|
;;;288    	}
;;;289    	else
;;;290    	{
;;;291    		AD_RANGE_10V();	/* 设置为正负10V */
000010  2101              MOVS     r1,#1
000012  4802              LDR      r0,|L6.28|
000014  f7fffffe          BL       GPIO_SetBits
                  |L6.24|
;;;292    	}
;;;293    }
000018  bd10              POP      {r4,pc}
;;;294    
                          ENDP

00001a  0000              DCW      0x0000
                  |L6.28|
                          DCD      0x40020400

                          AREA ||i.AD7606_StartConv||, CODE, READONLY, ALIGN=2

                  AD7606_StartConv PROC
;;;328    */
;;;329    void AD7606_StartConv(void)
000000  b510              PUSH     {r4,lr}
;;;330    {
;;;331    	/* 上升沿开始转换，低电平持续时间至少25ns  */
;;;332    	AD_CONVST_LOW();
000002  f44f6180          MOV      r1,#0x400
000006  4809              LDR      r0,|L7.44|
000008  f7fffffe          BL       GPIO_ResetBits
;;;333    	AD_CONVST_LOW();
00000c  f44f6180          MOV      r1,#0x400
000010  4806              LDR      r0,|L7.44|
000012  f7fffffe          BL       GPIO_ResetBits
;;;334    	AD_CONVST_LOW();	/* 连续执行2次，低电平约50ns */
000016  f44f6180          MOV      r1,#0x400
00001a  4804              LDR      r0,|L7.44|
00001c  f7fffffe          BL       GPIO_ResetBits
;;;335    	
;;;336    	AD_CONVST_HIGH();
000020  f44f6180          MOV      r1,#0x400
000024  4801              LDR      r0,|L7.44|
000026  f7fffffe          BL       GPIO_SetBits
;;;337    }
00002a  bd10              POP      {r4,pc}
;;;338    
                          ENDP

                  |L7.44|
                          DCD      0x40020c00

                          AREA ||i.bsp_spi_InitAD7606||, CODE, READONLY, ALIGN=2

                  bsp_spi_InitAD7606 PROC
;;;103    */
;;;104    void bsp_spi_InitAD7606(void)
000000  b510              PUSH     {r4,lr}
;;;105    {
;;;106    	AD7606_ConfigGPIO();		/* 配置GPIO */
000002  f7fffffe          BL       AD7606_ConfigGPIO
;;;107    	
;;;108    #ifdef HARD_SPI
;;;109    	AD7606_CfgSpiHard();
;;;110    #endif
;;;111    	
;;;112    	AD7606_SetInputRange(g_tAD7606.Range);	/* 设置采样量程 */
000006  491c              LDR      r1,|L8.120|
000008  7808              LDRB     r0,[r1,#0]  ; g_tAD7606
00000a  f7fffffe          BL       AD7606_SetInputRange
;;;113    
;;;114    	/* 设置过采样模式 */
;;;115    	//ad7606_SetOS(0);
;;;116    	AD7606_Reset();				/* 硬件复位复AD7606 */
00000e  f7fffffe          BL       AD7606_Reset
;;;117    	
;;;118    	AD_CONVST_HIGH();			/* CONVST脚设置为高电平 */	
000012  f44f6180          MOV      r1,#0x400
000016  4819              LDR      r0,|L8.124|
000018  f7fffffe          BL       GPIO_SetBits
;;;119    	RESET_1();
00001c  f44f7100          MOV      r1,#0x200
000020  4816              LDR      r0,|L8.124|
000022  f7fffffe          BL       GPIO_SetBits
;;;120    	RESET_1();
000026  f44f7100          MOV      r1,#0x200
00002a  4814              LDR      r0,|L8.124|
00002c  f7fffffe          BL       GPIO_SetBits
;;;121    	RESET_1();
000030  f44f7100          MOV      r1,#0x200
000034  4811              LDR      r0,|L8.124|
000036  f7fffffe          BL       GPIO_SetBits
;;;122    	RESET_1();
00003a  f44f7100          MOV      r1,#0x200
00003e  480f              LDR      r0,|L8.124|
000040  f7fffffe          BL       GPIO_SetBits
;;;123    	RESET_1();
000044  f44f7100          MOV      r1,#0x200
000048  480c              LDR      r0,|L8.124|
00004a  f7fffffe          BL       GPIO_SetBits
;;;124    	RESET_0();
00004e  f44f7100          MOV      r1,#0x200
000052  480a              LDR      r0,|L8.124|
000054  f7fffffe          BL       GPIO_ResetBits
;;;125    	RESET_0();
000058  f44f7100          MOV      r1,#0x200
00005c  4807              LDR      r0,|L8.124|
00005e  f7fffffe          BL       GPIO_ResetBits
;;;126    	RESET_0();
000062  f44f7100          MOV      r1,#0x200
000066  4805              LDR      r0,|L8.124|
000068  f7fffffe          BL       GPIO_ResetBits
;;;127    	RESET_0();
00006c  f44f7100          MOV      r1,#0x200
000070  4802              LDR      r0,|L8.124|
000072  f7fffffe          BL       GPIO_ResetBits
;;;128    }
000076  bd10              POP      {r4,pc}
;;;129    
                          ENDP

                  |L8.120|
                          DCD      g_tAD7606
                  |L8.124|
                          DCD      0x40020c00

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  s_adc_now
                          %        16

                          AREA ||.data||, DATA, ALIGN=0

                  g_tAD7606
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_spi_ad7606.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_bsp_spi_ad7606_c_d0061c5a____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_bsp_spi_ad7606_c_d0061c5a____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_bsp_spi_ad7606_c_d0061c5a____REVSH|
#line 144
|__asm___16_bsp_spi_ad7606_c_d0061c5a____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
