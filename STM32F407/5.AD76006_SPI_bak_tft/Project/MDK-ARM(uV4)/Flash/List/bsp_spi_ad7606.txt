; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_spi_ad7606.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_spi_ad7606.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX --omf_browse=.\flash\obj\bsp_spi_ad7606.crf ..\..\User\bsp_stm32f4xx\src\bsp_spi_ad7606.c]
                          THUMB

                          AREA ||i.AD7606_CfgSpiHard||, CODE, READONLY, ALIGN=2

                  AD7606_CfgSpiHard PROC
;;;184    */
;;;185    void AD7606_CfgSpiHard(void)
000000  b500              PUSH     {lr}
;;;186    {
000002  b085              SUB      sp,sp,#0x14
;;;187    	SPI_InitTypeDef  SPI_InitStructure;
;;;188    
;;;189    	/* 配置SPI硬件参数 */
;;;190    	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;	/* 数据方向：2线全双工 */
000004  2000              MOVS     r0,#0
000006  f8ad0000          STRH     r0,[sp,#0]
;;;191    	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		/* STM32的SPI工作模式 ：主机模式 */
00000a  f44f7082          MOV      r0,#0x104
00000e  f8ad0002          STRH     r0,[sp,#2]
;;;192    	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;	/* 数据位长度 ： 8位 */
000012  2000              MOVS     r0,#0
000014  f8ad0004          STRH     r0,[sp,#4]
;;;193    	/* SPI_CPOL和SPI_CPHA结合使用决定时钟和数据采样点的相位关系、
;;;194    	   本例配置: 总线空闲是高电平,第2个边沿（上升沿采样数据)
;;;195    	*/
;;;196    	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;			/* 时钟上升沿采样数据 */
000018  2002              MOVS     r0,#2
00001a  f8ad0006          STRH     r0,[sp,#6]
;;;197    	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;		/* 时钟的第2个边沿采样数据 */
00001e  2001              MOVS     r0,#1
000020  f8ad0008          STRH     r0,[sp,#8]
;;;198    	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;			/* 片选控制方式：软件控制 */
000024  0240              LSLS     r0,r0,#9
000026  f8ad000a          STRH     r0,[sp,#0xa]
;;;199    
;;;200    	/* 设置波特率预分频系数 SPI_BaudRatePrescaler_64 实测SCK周期 800ns ，12.5MHz */
;;;201    	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_64;
00002a  2028              MOVS     r0,#0x28
00002c  f8ad000c          STRH     r0,[sp,#0xc]
;;;202    
;;;203    	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	/* 数据位传输次序：高位先传 */
000030  2000              MOVS     r0,#0
000032  f8ad000e          STRH     r0,[sp,#0xe]
;;;204    	SPI_InitStructure.SPI_CRCPolynomial = 7;			/* CRC多项式寄存器，复位后为7。本例程不用 */
000036  2007              MOVS     r0,#7
000038  f8ad0010          STRH     r0,[sp,#0x10]
;;;205    	SPI_Init(SPI1, &SPI_InitStructure);
00003c  4669              MOV      r1,sp
00003e  4804              LDR      r0,|L1.80|
000040  f7fffffe          BL       SPI_Init
;;;206    
;;;207    	SPI_Cmd(SPI1, ENABLE);				/* 使能SPI  */
000044  2101              MOVS     r1,#1
000046  4802              LDR      r0,|L1.80|
000048  f7fffffe          BL       SPI_Cmd
;;;208    }
00004c  b005              ADD      sp,sp,#0x14
00004e  bd00              POP      {pc}
;;;209    
                          ENDP

                  |L1.80|
                          DCD      0x40013000

                          AREA ||i.AD7606_ConfigGPIO||, CODE, READONLY, ALIGN=2

                  AD7606_ConfigGPIO PROC
;;;128    */
;;;129    static void AD7606_ConfigGPIO(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;130    {
;;;131    	GPIO_InitTypeDef GPIO_InitStructure;
;;;132    
;;;133    	/* 打开GPIO时钟 */
;;;134    	RCC_AHB1PeriphClockCmd(RCC_CS | RCC_RANGE | RCC_BUSY | RCC_RESET | RCC_CONVST | RCC_OS0 | RCC_OS1 | RCC_OS2 , ENABLE);
000002  2101              MOVS     r1,#1
000004  205a              MOVS     r0,#0x5a
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;135    
;;;136    	/* 配置几个推完输出IO */
;;;137    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;		/* 设为输出口 */
00000a  2001              MOVS     r0,#1
00000c  f88d0004          STRB     r0,[sp,#4]
;;;138    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
000010  2000              MOVS     r0,#0
000012  f88d0006          STRB     r0,[sp,#6]
;;;139    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 上下拉电阻不使能 */
000016  f88d0007          STRB     r0,[sp,#7]
;;;140    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;	/* IO口最大速度 */
00001a  2003              MOVS     r0,#3
00001c  f88d0005          STRB     r0,[sp,#5]
;;;141    
;;;142    	GPIO_InitStructure.GPIO_Pin = PIN_RESET;
000020  2001              MOVS     r0,#1
000022  9000              STR      r0,[sp,#0]
;;;143    	GPIO_Init(PORT_RESET, &GPIO_InitStructure);
000024  4669              MOV      r1,sp
000026  4822              LDR      r0,|L2.176|
000028  f7fffffe          BL       GPIO_Init
;;;144    
;;;145    	GPIO_InitStructure.GPIO_Pin = PIN_CONVST;
00002c  2008              MOVS     r0,#8
00002e  9000              STR      r0,[sp,#0]
;;;146    	GPIO_Init(PORT_CONVST, &GPIO_InitStructure);
000030  4669              MOV      r1,sp
000032  4820              LDR      r0,|L2.180|
000034  f7fffffe          BL       GPIO_Init
;;;147    	
;;;148    	GPIO_InitStructure.GPIO_Pin = PIN_RANGE;
000038  2020              MOVS     r0,#0x20
00003a  9000              STR      r0,[sp,#0]
;;;149    	GPIO_Init(PORT_RANGE, &GPIO_InitStructure);
00003c  4669              MOV      r1,sp
00003e  481d              LDR      r0,|L2.180|
000040  f7fffffe          BL       GPIO_Init
;;;150    	
;;;151    	GPIO_InitStructure.GPIO_Pin = PIN_CS;
000044  2002              MOVS     r0,#2
000046  9000              STR      r0,[sp,#0]
;;;152    	GPIO_Init(PORT_CS, &GPIO_InitStructure);
000048  4669              MOV      r1,sp
00004a  4819              LDR      r0,|L2.176|
00004c  f7fffffe          BL       GPIO_Init
;;;153    	
;;;154    	GPIO_InitStructure.GPIO_Pin = PIN_OS0;
000050  2080              MOVS     r0,#0x80
000052  9000              STR      r0,[sp,#0]
;;;155    	GPIO_Init(PORT_OS0, &GPIO_InitStructure);
000054  4669              MOV      r1,sp
000056  4818              LDR      r0,|L2.184|
000058  f7fffffe          BL       GPIO_Init
;;;156    	
;;;157    	GPIO_InitStructure.GPIO_Pin = PIN_OS1;
00005c  2004              MOVS     r0,#4
00005e  9000              STR      r0,[sp,#0]
;;;158    	GPIO_Init(PORT_OS1, &GPIO_InitStructure);
000060  4669              MOV      r1,sp
000062  4813              LDR      r0,|L2.176|
000064  f7fffffe          BL       GPIO_Init
;;;159    	
;;;160    	GPIO_InitStructure.GPIO_Pin = PIN_OS2;
000068  f44f4000          MOV      r0,#0x8000
00006c  9000              STR      r0,[sp,#0]
;;;161    	GPIO_Init(PORT_OS2, &GPIO_InitStructure);
00006e  4669              MOV      r1,sp
000070  4812              LDR      r0,|L2.188|
000072  f7fffffe          BL       GPIO_Init
;;;162    
;;;163    
;;;164    	ADC_OS0_OFF	;
000076  2080              MOVS     r0,#0x80
000078  490f              LDR      r1,|L2.184|
00007a  3118              ADDS     r1,r1,#0x18
00007c  8008              STRH     r0,[r1,#0]
;;;165    	ADC_OS1_ON	;
00007e  2004              MOVS     r0,#4
000080  490b              LDR      r1,|L2.176|
000082  8348              STRH     r0,[r1,#0x1a]
;;;166    	ADC_OS2_ON	;
000084  0340              LSLS     r0,r0,#13
000086  490d              LDR      r1,|L2.188|
000088  311a              ADDS     r1,r1,#0x1a
00008a  8008              STRH     r0,[r1,#0]
;;;167    	/* 配置GPIO为浮动输入模式(实际上CPU复位后就是输入状态) */
;;;168    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;		/* 设为输入口 */
00008c  2000              MOVS     r0,#0
00008e  f88d0004          STRB     r0,[sp,#4]
;;;169    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
000092  f88d0006          STRB     r0,[sp,#6]
;;;170    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 无需上下拉电阻 */
000096  f88d0007          STRB     r0,[sp,#7]
;;;171    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	/* IO口最大速度 */
00009a  2002              MOVS     r0,#2
00009c  f88d0005          STRB     r0,[sp,#5]
;;;172    
;;;173    	GPIO_InitStructure.GPIO_Pin = PIN_BUSY;
0000a0  2040              MOVS     r0,#0x40
0000a2  9000              STR      r0,[sp,#0]
;;;174    	GPIO_Init(PORT_BUSY, &GPIO_InitStructure);
0000a4  4669              MOV      r1,sp
0000a6  4804              LDR      r0,|L2.184|
0000a8  f7fffffe          BL       GPIO_Init
;;;175    }
0000ac  bd1c              POP      {r2-r4,pc}
;;;176    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L2.176|
                          DCD      0x40021000
                  |L2.180|
                          DCD      0x40020400
                  |L2.184|
                          DCD      0x40020c00
                  |L2.188|
                          DCD      0x40021800

                          AREA ||i.AD7606_ReadAdc||, CODE, READONLY, ALIGN=2

                  AD7606_ReadAdc PROC
;;;368    */
;;;369    int16_t AD7606_ReadAdc(uint8_t _ch)
000000  4601              MOV      r1,r0
;;;370    {
;;;371    	int16_t sAdc;
;;;372    	
;;;373    	DISABLE_INT();	
000002  2001              MOVS     r0,#1
000004  f3808810          MSR      PRIMASK,r0
000008  bf00              NOP      
;;;374    	sAdc = s_adc_now[_ch];
00000a  4804              LDR      r0,|L3.28|
00000c  f9302011          LDRSH    r2,[r0,r1,LSL #1]
;;;375    	ENABLE_INT();
000010  2000              MOVS     r0,#0
000012  f3808810          MSR      PRIMASK,r0
000016  bf00              NOP      
;;;376    
;;;377    	return sAdc;
000018  4610              MOV      r0,r2
;;;378    }
00001a  4770              BX       lr
;;;379    
                          ENDP

                  |L3.28|
                          DCD      s_adc_now

                          AREA ||i.AD7606_Reset||, CODE, READONLY, ALIGN=2

                  AD7606_Reset PROC
;;;294    */
;;;295    void AD7606_Reset(void)
000000  b510              PUSH     {r4,lr}
;;;296    {
;;;297    	/* CS  SCLK拉高 */
;;;298    #ifdef SOFT_SPI
;;;299    		AD_CS_1();
000002  2102              MOVS     r1,#2
000004  480d              LDR      r0,|L4.60|
000006  f7fffffe          BL       GPIO_SetBits
;;;300    		//SCK_1();
;;;301    #endif
;;;302    
;;;303     	/* AD7606是高电平复位，要求最小脉宽50ns */
;;;304    	AD_RESET_LOW();
00000a  2101              MOVS     r1,#1
00000c  480b              LDR      r0,|L4.60|
00000e  f7fffffe          BL       GPIO_ResetBits
;;;305    	
;;;306    	AD_RESET_HIGH();
000012  2101              MOVS     r1,#1
000014  4809              LDR      r0,|L4.60|
000016  f7fffffe          BL       GPIO_SetBits
;;;307    	AD_RESET_HIGH();
00001a  2101              MOVS     r1,#1
00001c  4807              LDR      r0,|L4.60|
00001e  f7fffffe          BL       GPIO_SetBits
;;;308    	AD_RESET_HIGH();
000022  2101              MOVS     r1,#1
000024  4805              LDR      r0,|L4.60|
000026  f7fffffe          BL       GPIO_SetBits
;;;309    	AD_RESET_HIGH();
00002a  2101              MOVS     r1,#1
00002c  4803              LDR      r0,|L4.60|
00002e  f7fffffe          BL       GPIO_SetBits
;;;310    	
;;;311    	AD_RESET_LOW();
000032  2101              MOVS     r1,#1
000034  4801              LDR      r0,|L4.60|
000036  f7fffffe          BL       GPIO_ResetBits
;;;312    }
00003a  bd10              POP      {r4,pc}
;;;313    /*
                          ENDP

                  |L4.60|
                          DCD      0x40021000

                          AREA ||i.AD7606_Scan||, CODE, READONLY, ALIGN=2

                  AD7606_Scan PROC
;;;338    */
;;;339    void AD7606_Scan(void) 		/* 此函数代码按照时序编写 */
000000  b510              PUSH     {r4,lr}
;;;340    {
;;;341    	uint8_t i;			
;;;342    
;;;343    	/* BUSY = 0 时.ad7606处于空闲状态ad转换结束 */	
;;;344    	if (BUSY_IS_LOW())	   
000002  2140              MOVS     r1,#0x40
000004  4812              LDR      r0,|L5.80|
000006  f7fffffe          BL       GPIO_ReadInputDataBit
00000a  b9f8              CBNZ     r0,|L5.76|
;;;345        {
;;;346    		AD_CS_0(); /* SPI片选 = 0 */
00000c  2102              MOVS     r1,#2
00000e  4811              LDR      r0,|L5.84|
000010  f7fffffe          BL       GPIO_ResetBits
;;;347    	
;;;348    		for (i = 0; i < CH_NUM; i++)
000014  2400              MOVS     r4,#0
000016  e011              B        |L5.60|
                  |L5.24|
;;;349    		{
;;;350    			s_adc_now[i] = bsp_spiRead1();
000018  f7fffffe          BL       bsp_spiRead1
00001c  490e              LDR      r1,|L5.88|
00001e  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;351    			
;;;352    			s_adc_now[i] = s_adc_now[i] * 256 + bsp_spiRead1(); /* 读数据 */	
000022  f7fffffe          BL       bsp_spiRead1
000026  490c              LDR      r1,|L5.88|
000028  f8111014          LDRB     r1,[r1,r4,LSL #1]
00002c  eb002001          ADD      r0,r0,r1,LSL #8
000030  b200              SXTH     r0,r0
000032  4909              LDR      r1,|L5.88|
000034  f8210014          STRH     r0,[r1,r4,LSL #1]
000038  1c60              ADDS     r0,r4,#1              ;348
00003a  b2c4              UXTB     r4,r0                 ;348
                  |L5.60|
00003c  2c08              CMP      r4,#8                 ;348
00003e  dbeb              BLT      |L5.24|
;;;353    		}
;;;354    	
;;;355    		AD_CS_1(); /* SPI片选 = 1 */
000040  2102              MOVS     r1,#2
000042  4804              LDR      r0,|L5.84|
000044  f7fffffe          BL       GPIO_SetBits
;;;356    
;;;357    		AD7606_StartConv();	/* 给开始信号 */	
000048  f7fffffe          BL       AD7606_StartConv
                  |L5.76|
;;;358    	}
;;;359    }	  
00004c  bd10              POP      {r4,pc}
;;;360    
                          ENDP

00004e  0000              DCW      0x0000
                  |L5.80|
                          DCD      0x40020c00
                  |L5.84|
                          DCD      0x40021000
                  |L5.88|
                          DCD      s_adc_now

                          AREA ||i.AD7606_SetInputRange||, CODE, READONLY, ALIGN=2

                  AD7606_SetInputRange PROC
;;;274    */
;;;275    void AD7606_SetInputRange(uint8_t _ucRange)
000000  b510              PUSH     {r4,lr}
;;;276    {
000002  4604              MOV      r4,r0
;;;277    	if (_ucRange == 0)
000004  b924              CBNZ     r4,|L6.16|
;;;278    	{
;;;279    		AD_RANGE_5V();	/* 设置为正负5V */
000006  2120              MOVS     r1,#0x20
000008  4804              LDR      r0,|L6.28|
00000a  f7fffffe          BL       GPIO_ResetBits
00000e  e003              B        |L6.24|
                  |L6.16|
;;;280    	}
;;;281    	else
;;;282    	{
;;;283    		AD_RANGE_10V();	/* 设置为正负10V */
000010  2120              MOVS     r1,#0x20
000012  4802              LDR      r0,|L6.28|
000014  f7fffffe          BL       GPIO_SetBits
                  |L6.24|
;;;284    	}
;;;285    }
000018  bd10              POP      {r4,pc}
;;;286    
                          ENDP

00001a  0000              DCW      0x0000
                  |L6.28|
                          DCD      0x40020400

                          AREA ||i.AD7606_StartConv||, CODE, READONLY, ALIGN=2

                  AD7606_StartConv PROC
;;;320    */
;;;321    void AD7606_StartConv(void)
000000  b510              PUSH     {r4,lr}
;;;322    {
;;;323    	/* 上升沿开始转换，低电平持续时间至少25ns  */
;;;324    	AD_CONVST_LOW();
000002  2108              MOVS     r1,#8
000004  4807              LDR      r0,|L7.36|
000006  f7fffffe          BL       GPIO_ResetBits
;;;325    	AD_CONVST_LOW();
00000a  2108              MOVS     r1,#8
00000c  4805              LDR      r0,|L7.36|
00000e  f7fffffe          BL       GPIO_ResetBits
;;;326    	AD_CONVST_LOW();	/* 连续执行2次，低电平约50ns */
000012  2108              MOVS     r1,#8
000014  4803              LDR      r0,|L7.36|
000016  f7fffffe          BL       GPIO_ResetBits
;;;327    	
;;;328    	AD_CONVST_HIGH();
00001a  2108              MOVS     r1,#8
00001c  4801              LDR      r0,|L7.36|
00001e  f7fffffe          BL       GPIO_SetBits
;;;329    }
000022  bd10              POP      {r4,pc}
;;;330    
                          ENDP

                  |L7.36|
                          DCD      0x40020400

                          AREA ||i.bsp_spi_InitAD7606||, CODE, READONLY, ALIGN=2

                  bsp_spi_InitAD7606 PROC
;;;103    */
;;;104    void bsp_spi_InitAD7606(void)
000000  b510              PUSH     {r4,lr}
;;;105    {
;;;106    	AD7606_ConfigGPIO();		/* 配置GPIO */
000002  f7fffffe          BL       AD7606_ConfigGPIO
;;;107    	
;;;108    #ifdef HARD_SPI
;;;109    	AD7606_CfgSpiHard();
;;;110    #endif
;;;111    	
;;;112    	AD7606_SetInputRange(g_tAD7606.Range);	/* 设置采样量程 */
000006  4905              LDR      r1,|L8.28|
000008  7808              LDRB     r0,[r1,#0]  ; g_tAD7606
00000a  f7fffffe          BL       AD7606_SetInputRange
;;;113    
;;;114    	/* 设置过采样模式 */
;;;115    	//ad7606_SetOS(0);
;;;116    	AD7606_Reset();				/* 硬件复位复AD7606 */
00000e  f7fffffe          BL       AD7606_Reset
;;;117    	
;;;118    	AD_CONVST_HIGH();			/* CONVST脚设置为高电平 */	
000012  2108              MOVS     r1,#8
000014  4802              LDR      r0,|L8.32|
000016  f7fffffe          BL       GPIO_SetBits
;;;119    }
00001a  bd10              POP      {r4,pc}
;;;120    
                          ENDP

                  |L8.28|
                          DCD      g_tAD7606
                  |L8.32|
                          DCD      0x40020400

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  s_adc_now
                          %        16

                          AREA ||.data||, DATA, ALIGN=0

                  g_tAD7606
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_spi_ad7606.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_bsp_spi_ad7606_c_d0061c5a____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_bsp_spi_ad7606_c_d0061c5a____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_bsp_spi_ad7606_c_d0061c5a____REVSH|
#line 144
|__asm___16_bsp_spi_ad7606_c_d0061c5a____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
