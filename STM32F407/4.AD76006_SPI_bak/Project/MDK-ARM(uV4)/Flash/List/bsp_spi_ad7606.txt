; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_spi_ad7606.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_spi_ad7606.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX --omf_browse=.\flash\obj\bsp_spi_ad7606.crf ..\..\User\bsp_stm32f4xx\src\bsp_spi_ad7606.c]
                          THUMB

                          AREA ||i.AD7606_CfgSpiHard||, CODE, READONLY, ALIGN=2

                  AD7606_CfgSpiHard PROC
;;;136    */
;;;137    void AD7606_CfgSpiHard(void)
000000  b500              PUSH     {lr}
;;;138    {
000002  b085              SUB      sp,sp,#0x14
;;;139    	SPI_InitTypeDef  SPI_InitStructure;
;;;140    
;;;141    	/* 配置SPI硬件参数 */
;;;142    	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;	/* 数据方向：2线全双工 */
000004  2000              MOVS     r0,#0
000006  f8ad0000          STRH     r0,[sp,#0]
;;;143    	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		/* STM32的SPI工作模式 ：主机模式 */
00000a  f44f7082          MOV      r0,#0x104
00000e  f8ad0002          STRH     r0,[sp,#2]
;;;144    	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;	/* 数据位长度 ： 8位 */
000012  2000              MOVS     r0,#0
000014  f8ad0004          STRH     r0,[sp,#4]
;;;145    	/* SPI_CPOL和SPI_CPHA结合使用决定时钟和数据采样点的相位关系、
;;;146    	   本例配置: 总线空闲是高电平,第2个边沿（上升沿采样数据)
;;;147    	*/
;;;148    	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;			/* 时钟上升沿采样数据 */
000018  2002              MOVS     r0,#2
00001a  f8ad0006          STRH     r0,[sp,#6]
;;;149    	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;		/* 时钟的第2个边沿采样数据 */
00001e  2001              MOVS     r0,#1
000020  f8ad0008          STRH     r0,[sp,#8]
;;;150    	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;			/* 片选控制方式：软件控制 */
000024  0240              LSLS     r0,r0,#9
000026  f8ad000a          STRH     r0,[sp,#0xa]
;;;151    
;;;152    	/* 设置波特率预分频系数 SPI_BaudRatePrescaler_64 实测SCK周期 800ns ，12.5MHz */
;;;153    	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_64;
00002a  2028              MOVS     r0,#0x28
00002c  f8ad000c          STRH     r0,[sp,#0xc]
;;;154    
;;;155    	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	/* 数据位传输次序：高位先传 */
000030  2000              MOVS     r0,#0
000032  f8ad000e          STRH     r0,[sp,#0xe]
;;;156    	SPI_InitStructure.SPI_CRCPolynomial = 7;			/* CRC多项式寄存器，复位后为7。本例程不用 */
000036  2007              MOVS     r0,#7
000038  f8ad0010          STRH     r0,[sp,#0x10]
;;;157    	SPI_Init(SPI1, &SPI_InitStructure);
00003c  4669              MOV      r1,sp
00003e  4804              LDR      r0,|L1.80|
000040  f7fffffe          BL       SPI_Init
;;;158    
;;;159    	SPI_Cmd(SPI1, ENABLE);				/* 使能SPI  */
000044  2101              MOVS     r1,#1
000046  4802              LDR      r0,|L1.80|
000048  f7fffffe          BL       SPI_Cmd
;;;160    }
00004c  b005              ADD      sp,sp,#0x14
00004e  bd00              POP      {pc}
;;;161    
                          ENDP

                  |L1.80|
                          DCD      0x40013000

                          AREA ||i.AD7606_ConfigGPIO||, CODE, READONLY, ALIGN=2

                  AD7606_ConfigGPIO PROC
;;;93     */
;;;94     static void AD7606_ConfigGPIO(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;95     {
;;;96     	GPIO_InitTypeDef GPIO_InitStructure;
;;;97     
;;;98     	/* 打开GPIO时钟 */
;;;99     	RCC_AHB1PeriphClockCmd(RCC_CS | RCC_RANGE | RCC_BUSY | RCC_RESET | RCC_CONVST, ENABLE);
000002  2101              MOVS     r1,#1
000004  201a              MOVS     r0,#0x1a
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;100    
;;;101    	/* 配置几个推完输出IO */
;;;102    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;		/* 设为输出口 */
00000a  2001              MOVS     r0,#1
00000c  f88d0004          STRB     r0,[sp,#4]
;;;103    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
000010  2000              MOVS     r0,#0
000012  f88d0006          STRB     r0,[sp,#6]
;;;104    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 上下拉电阻不使能 */
000016  f88d0007          STRB     r0,[sp,#7]
;;;105    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;	/* IO口最大速度 */
00001a  2003              MOVS     r0,#3
00001c  f88d0005          STRB     r0,[sp,#5]
;;;106    
;;;107    	GPIO_InitStructure.GPIO_Pin = PIN_RESET;
000020  2001              MOVS     r0,#1
000022  9000              STR      r0,[sp,#0]
;;;108    	GPIO_Init(PORT_RESET, &GPIO_InitStructure);
000024  4669              MOV      r1,sp
000026  4814              LDR      r0,|L2.120|
000028  f7fffffe          BL       GPIO_Init
;;;109    
;;;110    	GPIO_InitStructure.GPIO_Pin = PIN_CONVST;
00002c  f44f5000          MOV      r0,#0x2000
000030  9000              STR      r0,[sp,#0]
;;;111    	GPIO_Init(PORT_CONVST, &GPIO_InitStructure);
000032  4669              MOV      r1,sp
000034  4810              LDR      r0,|L2.120|
000036  f7fffffe          BL       GPIO_Init
;;;112    	
;;;113    	GPIO_InitStructure.GPIO_Pin = PIN_RANGE;
00003a  f44f7080          MOV      r0,#0x100
00003e  9000              STR      r0,[sp,#0]
;;;114    	GPIO_Init(PORT_RANGE, &GPIO_InitStructure);
000040  4669              MOV      r1,sp
000042  480e              LDR      r0,|L2.124|
000044  f7fffffe          BL       GPIO_Init
;;;115    	
;;;116    	GPIO_InitStructure.GPIO_Pin = PIN_CS;
000048  2040              MOVS     r0,#0x40
00004a  9000              STR      r0,[sp,#0]
;;;117    	GPIO_Init(PORT_CS, &GPIO_InitStructure);
00004c  4669              MOV      r1,sp
00004e  480c              LDR      r0,|L2.128|
000050  f7fffffe          BL       GPIO_Init
;;;118    
;;;119    	/* 配置GPIO为浮动输入模式(实际上CPU复位后就是输入状态) */
;;;120    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;		/* 设为输入口 */
000054  2000              MOVS     r0,#0
000056  f88d0004          STRB     r0,[sp,#4]
;;;121    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
00005a  f88d0006          STRB     r0,[sp,#6]
;;;122    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 无需上下拉电阻 */
00005e  f88d0007          STRB     r0,[sp,#7]
;;;123    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	/* IO口最大速度 */
000062  2002              MOVS     r0,#2
000064  f88d0005          STRB     r0,[sp,#5]
;;;124    
;;;125    	GPIO_InitStructure.GPIO_Pin = PIN_BUSY;
000068  2080              MOVS     r0,#0x80
00006a  9000              STR      r0,[sp,#0]
;;;126    	GPIO_Init(PORT_BUSY, &GPIO_InitStructure);
00006c  4669              MOV      r1,sp
00006e  4804              LDR      r0,|L2.128|
000070  f7fffffe          BL       GPIO_Init
;;;127    }
000074  bd1c              POP      {r2-r4,pc}
;;;128    
                          ENDP

000076  0000              DCW      0x0000
                  |L2.120|
                          DCD      0x40021000
                  |L2.124|
                          DCD      0x40020400
                  |L2.128|
                          DCD      0x40020c00

                          AREA ||i.AD7606_ReadAdc||, CODE, READONLY, ALIGN=2

                  AD7606_ReadAdc PROC
;;;320    */
;;;321    int16_t AD7606_ReadAdc(uint8_t _ch)
000000  4601              MOV      r1,r0
;;;322    {
;;;323    	int16_t sAdc;
;;;324    	
;;;325    	DISABLE_INT();	
000002  2001              MOVS     r0,#1
000004  f3808810          MSR      PRIMASK,r0
000008  bf00              NOP      
;;;326    	sAdc = s_adc_now[_ch];
00000a  4804              LDR      r0,|L3.28|
00000c  f9302011          LDRSH    r2,[r0,r1,LSL #1]
;;;327    	ENABLE_INT();
000010  2000              MOVS     r0,#0
000012  f3808810          MSR      PRIMASK,r0
000016  bf00              NOP      
;;;328    
;;;329    	return sAdc;
000018  4610              MOV      r0,r2
;;;330    }
00001a  4770              BX       lr
;;;331    
                          ENDP

                  |L3.28|
                          DCD      s_adc_now

                          AREA ||i.AD7606_Reset||, CODE, READONLY, ALIGN=2

                  AD7606_Reset PROC
;;;246    */
;;;247    void AD7606_Reset(void)
000000  b510              PUSH     {r4,lr}
;;;248    {
;;;249    	/* CS  SCLK拉高 */
;;;250    #ifdef SOFT_SPI
;;;251    		AD_CS_1();
000002  2140              MOVS     r1,#0x40
000004  480d              LDR      r0,|L4.60|
000006  f7fffffe          BL       GPIO_SetBits
;;;252    		//SCK_1();
;;;253    #endif
;;;254    
;;;255     	/* AD7606是高电平复位，要求最小脉宽50ns */
;;;256    	AD_RESET_LOW();
00000a  2101              MOVS     r1,#1
00000c  480c              LDR      r0,|L4.64|
00000e  f7fffffe          BL       GPIO_ResetBits
;;;257    	
;;;258    	AD_RESET_HIGH();
000012  2101              MOVS     r1,#1
000014  480a              LDR      r0,|L4.64|
000016  f7fffffe          BL       GPIO_SetBits
;;;259    	AD_RESET_HIGH();
00001a  2101              MOVS     r1,#1
00001c  4808              LDR      r0,|L4.64|
00001e  f7fffffe          BL       GPIO_SetBits
;;;260    	AD_RESET_HIGH();
000022  2101              MOVS     r1,#1
000024  4806              LDR      r0,|L4.64|
000026  f7fffffe          BL       GPIO_SetBits
;;;261    	AD_RESET_HIGH();
00002a  2101              MOVS     r1,#1
00002c  4804              LDR      r0,|L4.64|
00002e  f7fffffe          BL       GPIO_SetBits
;;;262    	
;;;263    	AD_RESET_LOW();
000032  2101              MOVS     r1,#1
000034  4802              LDR      r0,|L4.64|
000036  f7fffffe          BL       GPIO_ResetBits
;;;264    }
00003a  bd10              POP      {r4,pc}
;;;265    /*
                          ENDP

                  |L4.60|
                          DCD      0x40020c00
                  |L4.64|
                          DCD      0x40021000

                          AREA ||i.AD7606_Scan||, CODE, READONLY, ALIGN=2

                  AD7606_Scan PROC
;;;290    */
;;;291    void AD7606_Scan(void) 		/* 此函数代码按照时序编写 */
000000  b510              PUSH     {r4,lr}
;;;292    {
;;;293    	uint8_t i;			
;;;294    
;;;295    	/* BUSY = 0 时.ad7606处于空闲状态ad转换结束 */	
;;;296    	if (BUSY_IS_LOW())	   
000002  2180              MOVS     r1,#0x80
000004  4812              LDR      r0,|L5.80|
000006  f7fffffe          BL       GPIO_ReadInputDataBit
00000a  b9f8              CBNZ     r0,|L5.76|
;;;297        {
;;;298    		AD_CS_0(); /* SPI片选 = 0 */
00000c  2140              MOVS     r1,#0x40
00000e  4810              LDR      r0,|L5.80|
000010  f7fffffe          BL       GPIO_ResetBits
;;;299    	
;;;300    		for (i = 0; i < CH_NUM; i++)
000014  2400              MOVS     r4,#0
000016  e011              B        |L5.60|
                  |L5.24|
;;;301    		{
;;;302    			s_adc_now[i] = bsp_spiRead1();
000018  f7fffffe          BL       bsp_spiRead1
00001c  490d              LDR      r1,|L5.84|
00001e  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;303    			
;;;304    			s_adc_now[i] = s_adc_now[i] * 256 + bsp_spiRead1(); /* 读数据 */	
000022  f7fffffe          BL       bsp_spiRead1
000026  490b              LDR      r1,|L5.84|
000028  f8111014          LDRB     r1,[r1,r4,LSL #1]
00002c  eb002001          ADD      r0,r0,r1,LSL #8
000030  b200              SXTH     r0,r0
000032  4908              LDR      r1,|L5.84|
000034  f8210014          STRH     r0,[r1,r4,LSL #1]
000038  1c60              ADDS     r0,r4,#1              ;300
00003a  b2c4              UXTB     r4,r0                 ;300
                  |L5.60|
00003c  2c08              CMP      r4,#8                 ;300
00003e  dbeb              BLT      |L5.24|
;;;305    		}
;;;306    	
;;;307    		AD_CS_1(); /* SPI片选 = 1 */
000040  2140              MOVS     r1,#0x40
000042  4803              LDR      r0,|L5.80|
000044  f7fffffe          BL       GPIO_SetBits
;;;308    
;;;309    		AD7606_StartConv();	/* 给开始信号 */	
000048  f7fffffe          BL       AD7606_StartConv
                  |L5.76|
;;;310    	}
;;;311    }	  
00004c  bd10              POP      {r4,pc}
;;;312    
                          ENDP

00004e  0000              DCW      0x0000
                  |L5.80|
                          DCD      0x40020c00
                  |L5.84|
                          DCD      s_adc_now

                          AREA ||i.AD7606_SetInputRange||, CODE, READONLY, ALIGN=2

                  AD7606_SetInputRange PROC
;;;226    */
;;;227    void AD7606_SetInputRange(uint8_t _ucRange)
000000  b510              PUSH     {r4,lr}
;;;228    {
000002  4604              MOV      r4,r0
;;;229    	if (_ucRange == 0)
000004  b92c              CBNZ     r4,|L6.18|
;;;230    	{
;;;231    		AD_RANGE_5V();	/* 设置为正负5V */
000006  f44f7180          MOV      r1,#0x100
00000a  4805              LDR      r0,|L6.32|
00000c  f7fffffe          BL       GPIO_ResetBits
000010  e004              B        |L6.28|
                  |L6.18|
;;;232    	}
;;;233    	else
;;;234    	{
;;;235    		AD_RANGE_10V();	/* 设置为正负10V */
000012  f44f7180          MOV      r1,#0x100
000016  4802              LDR      r0,|L6.32|
000018  f7fffffe          BL       GPIO_SetBits
                  |L6.28|
;;;236    	}
;;;237    }
00001c  bd10              POP      {r4,pc}
;;;238    
                          ENDP

00001e  0000              DCW      0x0000
                  |L6.32|
                          DCD      0x40020400

                          AREA ||i.AD7606_StartConv||, CODE, READONLY, ALIGN=2

                  AD7606_StartConv PROC
;;;272    */
;;;273    void AD7606_StartConv(void)
000000  b510              PUSH     {r4,lr}
;;;274    {
;;;275    	/* 上升沿开始转换，低电平持续时间至少25ns  */
;;;276    	AD_CONVST_LOW();
000002  f44f5100          MOV      r1,#0x2000
000006  4809              LDR      r0,|L7.44|
000008  f7fffffe          BL       GPIO_ResetBits
;;;277    	AD_CONVST_LOW();
00000c  f44f5100          MOV      r1,#0x2000
000010  4806              LDR      r0,|L7.44|
000012  f7fffffe          BL       GPIO_ResetBits
;;;278    	AD_CONVST_LOW();	/* 连续执行2次，低电平约50ns */
000016  f44f5100          MOV      r1,#0x2000
00001a  4804              LDR      r0,|L7.44|
00001c  f7fffffe          BL       GPIO_ResetBits
;;;279    	
;;;280    	AD_CONVST_HIGH();
000020  f44f5100          MOV      r1,#0x2000
000024  4801              LDR      r0,|L7.44|
000026  f7fffffe          BL       GPIO_SetBits
;;;281    }
00002a  bd10              POP      {r4,pc}
;;;282    
                          ENDP

                  |L7.44|
                          DCD      0x40021000

                          AREA ||i.bsp_spi_InitAD7606||, CODE, READONLY, ALIGN=2

                  bsp_spi_InitAD7606 PROC
;;;68     */
;;;69     void bsp_spi_InitAD7606(void)
000000  b510              PUSH     {r4,lr}
;;;70     {
;;;71     	AD7606_ConfigGPIO();		/* 配置GPIO */
000002  f7fffffe          BL       AD7606_ConfigGPIO
;;;72     	
;;;73     #ifdef HARD_SPI
;;;74     	AD7606_CfgSpiHard();
;;;75     #endif
;;;76     	
;;;77     	AD7606_SetInputRange(g_tAD7606.Range);	/* 设置采样量程 */
000006  4906              LDR      r1,|L8.32|
000008  7808              LDRB     r0,[r1,#0]  ; g_tAD7606
00000a  f7fffffe          BL       AD7606_SetInputRange
;;;78     
;;;79     	/* 设置过采样模式 */
;;;80     	//ad7606_SetOS(0);
;;;81     	AD7606_Reset();				/* 硬件复位复AD7606 */
00000e  f7fffffe          BL       AD7606_Reset
;;;82     	
;;;83     	AD_CONVST_HIGH();			/* CONVST脚设置为高电平 */	
000012  f44f5100          MOV      r1,#0x2000
000016  4803              LDR      r0,|L8.36|
000018  f7fffffe          BL       GPIO_SetBits
;;;84     }
00001c  bd10              POP      {r4,pc}
;;;85     
                          ENDP

00001e  0000              DCW      0x0000
                  |L8.32|
                          DCD      g_tAD7606
                  |L8.36|
                          DCD      0x40021000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  s_adc_now
                          %        16

                          AREA ||.data||, DATA, ALIGN=0

                  g_tAD7606
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_spi_ad7606.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_bsp_spi_ad7606_c_d0061c5a____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_bsp_spi_ad7606_c_d0061c5a____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_bsp_spi_ad7606_c_d0061c5a____REVSH|
#line 144
|__asm___16_bsp_spi_ad7606_c_d0061c5a____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
